# 使用该仓库同步项目进度

1. 推荐使用 ``Markdown``来记录，最终方便展示和提交，大体框架如下
2. 推荐使用 ``ChatGPT``，帮助生成代码、解决疑问
3. 推荐但不限于的搜集文献网站：[谷歌学术](https://scholar.google.com.hk/?hl=zh-CN) [arxiv](https://arxiv.org/)
4. git常用指令网站（可供参考）： [git简易指南](https://www.bootcss.com/p/git-guide/)

# 算法研究报告格式说明

为了统一算法研究的输出内容，这里对算法的研究报告做一定的格式说明，每一个算法报告中应包含以下内容：

1. **算法简介或算法定义**；
2. **算法的已知特点、优点、缺点以及适用场景**；
3. **算法的原理和方法描述**，包括数学模型（公式）及解释以及算法复杂度的描述，主要是时间复杂度；
4. **最终输出的源数据曲线和经过算法处理后的数据曲线的对比图形**，可以是不同参数或者不同数据的多张对比图形；
5. **研究过程的参考文献**。

# 源代码实现及调优要求

源代码以单独的附件，算法实现最终输出统一为python代码（`.py`文件）或`python`项目整体压缩包给出，算法实现及调优要求如下：

1. **源代码至少包含两个函数**，一个是算法具体实现方法接口，一个是算法评估方法接口；
2. **算法实现时引用的Python框架必须注明版本号**；
3. **算法接口方法名统一用小写字母**，单词之间用下划线分割，滤波器算法使用 `filter_`开头，算法评估使用 `filter_evaluate_`开头，无论是方法命名还是变量命名，均使用有意义的单词；
4. **算法接口方法的参数**除一个必须的业务数据外，其他可调节参数应定义在接口方法中作为参数传入，算法调优的最优参数值作为默认值；
5. **重要位置添加注释**，以增加代码可读性。

# 工业控制场景下滤波器算法研究

- [使用该仓库同步项目进度](#使用该仓库同步项目进度)
- [算法研究报告格式说明](#算法研究报告格式说明)
- [源代码实现及调优要求](#源代码实现及调优要求)
- [工业控制场景下滤波器算法研究](#工业控制场景下滤波器算法研究)
  - [Requirements](#requirements)
  - [1.一阶滤波](#1一阶滤波)
    - [一阶低通滤波](#一阶低通滤波)
      - [算法方法描述](#算法方法描述)
      - [数学模型及解释](#数学模型及解释)
      - [算法复杂度描述](#算法复杂度描述)
      - [代码](#代码)
      - [输出结果](#输出结果)
      - [优点](#优点)
      - [缺点](#缺点)
      - [优化方向](#优化方向)
      - [适用场景](#适用场景)
      - [总结](#总结)
    - [一阶高通滤波](#一阶高通滤波)
      - [算法方法描述](#算法方法描述-1)
      - [数学模型解释](#数学模型解释)
      - [算法复杂度描述](#算法复杂度描述-1)
      - [代码](#代码-1)
      - [输出结果](#输出结果-1)
      - [优点](#优点-1)
      - [缺点](#缺点-1)
      - [优化方向](#优化方向-1)
      - [适用场景](#适用场景-1)
      - [总结](#总结-1)
    - [参考文献](#参考文献)
  - [2.二阶滤波](#2二阶滤波)
    - [算法方法描述](#算法方法描述-2)
    - [代码](#代码-2)
    - [输出结果](#输出结果-2)
    - [数学模型解释](#数学模型解释-1)
    - [特点](#特点)
    - [优点](#优点-2)
    - [缺点](#缺点-2)
    - [适用场景](#适用场景-2)
  - [3.FIP滤波](#3fip滤波)
    - [算法简介或算法定义](#算法简介或算法定义)
    - [算法的特点、优点、缺点以及适用场景](#算法的特点优点缺点以及适用场景)
      - [特点](#特点-1)
      - [优点](#优点-3)
      - [缺点](#缺点-3)
      - [适用场景](#适用场景-3)
    - [算法的原理和方法描述](#算法的原理和方法描述)
    - [数学模型](#数学模型)
    - [FIP的迭代步骤](#fip的迭代步骤)
    - [代码](#代码-3)
    - [输出结果](#输出结果-3)
    - [时间复杂度](#时间复杂度)
    - [总结](#总结-2)
  - [4.椭圆滤波](#4椭圆滤波)
    - [算法简介或算法定义](#算法简介或算法定义-1)
    - [算法的特点、优点、缺点以及适用场景](#算法的特点优点缺点以及适用场景-1)
      - [特点](#特点-2)
      - [优点](#优点-4)
      - [缺点](#缺点-4)
      - [适用场景](#适用场景-4)
    - [算法的原理和方法描述](#算法的原理和方法描述-1)
    - [数学模型](#数学模型-1)
    - [设计参数](#设计参数)
    - [代码](#代码-4)
    - [输出结果](#输出结果-4)
    - [时间复杂度](#时间复杂度-1)
    - [总结](#总结-3)
  - [5.史密斯滤波器](#5史密斯滤波器)
    - [算法简介或算法定义](#算法简介或算法定义-2)
    - [算法的特点、优点、缺点以及适用场景](#算法的特点优点缺点以及适用场景-2)
      - [特点](#特点-3)
      - [优点](#优点-5)
      - [缺点](#缺点-5)
      - [适用场景](#适用场景-5)
    - [算法的原理和方法描述](#算法的原理和方法描述-2)
    - [数学模型](#数学模型-2)
    - [设计步骤](#设计步骤)
    - [代码](#代码-5)
    - [输出结果](#输出结果-5)
    - [时间复杂度](#时间复杂度-2)
    - [总结](#总结-4)
  - [6.拉普拉斯滤波器](#6拉普拉斯滤波器)
  - [7.均值迁移滤波（Mean Shift Filter）](#7均值迁移滤波mean-shift-filter)
  - [8.算术平均滤波法](#8算术平均滤波法)
  - [9.IIR 数字滤波器](#9iir-数字滤波器)
  - [10.高斯滤波（Gaussian Filter）](#10高斯滤波gaussian-filter)
  - [11.中值滤波（Median Filter）](#11中值滤波median-filter)
  - [12.维纳滤波器](#12维纳滤波器)
  - [13.卡尔曼滤波](#13卡尔曼滤波)

## Requirements

自动生成 ``requirements.txt``:

``pip freeze > requirements.txt``

项目支持环境（commited time: 2024.7.11）

``pip install -r requirements.txt``

## 1.一阶滤波

一阶滤波器是一种基本的滤波器，用于平滑信号或减少噪声。常见的一阶滤波器包括低通滤波器和高通滤波器。以下是关于一阶滤波器算法的介绍。

### 一阶低通滤波

#### 算法方法描述

一阶低通滤波器通过对输入信号和上一次的输出信号进行加权平均来工作。该方法依赖于一个称为滤波系数的参数，该参数决定了当前输入信号与上一次输出在新输出中的相对重要性。

#### 数学模型及解释

一阶低通滤波器的数学模型可以表示为：

\[ y[n] = \alpha \cdot x[n] + (1 - \alpha) \cdot y[n-1] \]

其中：

- \(y[n]\) 是当前输出；
- \(x[n]\) 是当前输入；
- \(y[n-1]\) 是上一次的输出；
- \(\alpha\) 是滤波系数，\(0 < \alpha < 1\)。

在这个模型中，\(\alpha\) 控制着新输入信号 \(x[n]\) 对输出 \(y[n]\) 的贡献程度。较高的 \(\alpha\) 值使得滤波器对输入信号的变化更敏感，而较低的 \(\alpha\) 值使得输出更加平滑，但对信号的变化反应较慢。

#### 算法复杂度描述

- **时间复杂度**：一阶低通滤波器的时间复杂度为 \(O(1)\)。对于每个输入信号 \(x[n]\)，滤波器仅执行一次加权平均计算，计算复杂度不随输入信号的长度变化而变化。

#### 代码

[一阶低通滤波器](LowPass_Filter.py)

#### 输出结果

![一阶低通滤波](figure/Figure_1.png)

- 蓝线：原始数据
- 黄线：滤波系数为0.1
- 绿线：滤波系数为0.3
- 红线：滤波系数为0.5

#### 优点

1. 简单易实现：一阶滤波器结构简单，易于设计和实现，适用于对处理速度和资源消耗有限制的场合。
2. 周期干扰抑制：对于周期性的干扰信号，一阶滤波器能有效地进行抑制，提高信号的质量。
3. 平滑信号：通过调整滤波系数，一阶滤波器可以平滑输出信号，减少噪声，适用于信号预处理。

#### 缺点

1. 相位滞后：一阶滤波器会引入相位滞后，导致输出信号与输入信号之间存在延迟，影响系统的实时性。
2. 有限的频率抑制能力：不能滤除高于采样频率一半（奈奎斯特频率）的干扰信号，限制了其在高频应用中的效果。
3. 灵敏度与稳定性的权衡：滤波系数的选择需要在灵敏度和稳定性之间做出权衡，难以同时满足两者。

#### 优化方向

1. 截止频率优化：截止频率决定了滤波器的频率响应。根据应用的需要，你可以优化截止频率，使其更好地匹配所需的频率范围。选择适当的电阻和电容值可以实现所需的截止频率。
2. 时间常数调整：时间常数（τ = RC）影响滤波器的响应速度。如果需要更快的响应速度或更慢的响应速度，可以调整电阻和电容的值以更改时间常数。
3. 降低噪声：在一阶低通滤波器的输入信号中存在噪声时，你可以考虑优化滤波器以更好地抑制噪声。这可能包括使用更高阶的滤波器或添加额外的滤波阶段。
4. 增加滤波器阶数：一阶滤波器只有一个电阻和一个电容，因此其滤波能力有限。如果需要更高的滤波性能，可以考虑使用更高阶的滤波器，如二阶、三阶等。
5. 数字滤波器替代：一阶低通滤波器通常是模拟滤波器，但在数字信号处理中也可以使用数字滤波器来实现相似的功能。数字滤波器具有更大的灵活性，可以根据需要进行更复杂的优化和调整。
6. 滤波器类型选择：除了一阶低通滤波器，还有其他类型的滤波器，如巴特沃斯滤波器、切比雪夫滤波器等。选择适合特定应用的滤波器类型也是一种优化方法。
7. 硬件实现：如果需要在特定硬件平台上实现滤波器，可以考虑优化电路设计，以提高性能、降低功耗或减小尺寸。
8. 实时性能：如果需要实时滤波，考虑滤波器的计算复杂性，以确保在实时应用中满足性能要求

#### 适用场景

1. 信号预处理：在数据采集系统中，一阶滤波器常用于信号的预处理阶段，以减少噪声和平滑信号，为后续处理提供更清晰的信号。
2. 模拟信号处理：在模拟电路设计中，一阶滤波器用于抑制不需要的高频或低频成分，改善信号的质量。
3. 实时系统：在需要快速响应的实时系统中，尽管一阶滤波器会引入一定的延迟，但由于其结构简单，仍然是一种可行的选择。
4. 低成本应用：对于成本敏感的应用，一阶滤波器由于其简单性，成为一种经济有效的解决方案。

#### 总结

一阶低通滤波器是一种高效且实现简单的信号处理工具，适用于去除高频噪声和信号平滑。由于其时间复杂度为 \(O(1)\)，它特别适合于实时信号处理应用，其中计算资源可能受限。通过适当选择滤波系数 \(\alpha\)，可以根据具体应用需求调整滤波器的行为，平衡信号的平滑度和响应速度。

### 一阶高通滤波

#### 算法方法描述

一阶高通滤波器可以通过电子电路实现，也可以通过数字信号处理技术实现。在数字域中，一阶高通滤波器通常通过差分方程实现，该方程根据当前和过去的输入值以及过去的输出值来计算当前的输出值。

#### 数学模型解释

一阶高通滤波器的传递函数可以表示为： \[ H(s) = \frac{s}{s + \omega_c} \] 其中，\(s\) 是复频率变量，\(\omega_c\) 是角频率。在数字实现中，使用Z变换将上述传递函数转换为离散时间形式。

#### 算法复杂度描述

一阶高通滤波器的时间复杂度为 (O(1))，因为每个输出样本的计算仅依赖于有限数量的输入和输出样本。

#### 代码

[一阶高通滤波器](HighPass_Filter.py)

#### 输出结果

![一阶高通滤波](figure/Figure_2.png)

#### 优点

- 简单易实现，适用于实时信号处理。
- 计算复杂度低，适合于资源受限的系统。

#### 缺点

- 由于是一阶滤波器，其斜率较低，滤波效果不如高阶滤波器。
- 可能会引入相位偏移，影响信号的波形。

#### 优化方向

- 通过调整截止频率，可以优化滤波器的性能，以更好地适应特定应用的需求。
- 在需要更陡峭的滤波斜率时，可以考虑使用二阶或更高阶的高通滤波器。

#### 适用场景

- 信号预处理，去除低频干扰。
- 音频处理，如增强语音信号中的高频成分。
- 电子电路设计，用于信号调理和频率选择。

#### 总结

一阶高通滤波器主要用于去除信号中的低频成分，只允许高频信号通过。它在信号处理、音频处理和电子工程等领域有广泛的应用。

### 参考文献

[彻底理解一阶低通滤波（原理+代码+模型+实际车企应用例子）](https://blog.csdn.net/weixin_43780292/article/details/134351122)  
[“一阶数字低通滤波器”原理推导（含仿真和代码实现）](https://blog.csdn.net/weixin_42887190/article/details/125749509)

## 2.二阶滤波

### 算法方法描述

二阶滤波器的传输函数一般为二次多项式形式，具有两个极点和两个零点。其传输函数形式为：

\[ H(s) = \frac{b_0 + b_1 s + b_2 s^2}{a_0 + a_1 s + a_2 s^2} \]

其中，\( b_0, b_1, b_2 \) 是分子多项式的系数，\( a_0, a_1, a_2 \) 是分母多项式的系数。二阶滤波器可以实现更复杂的频率响应特性，常用于需要更高精度的滤波场合。

### 代码

[二阶滤波器](Second_Order_Filter.py)

### 输出结果

![二阶滤波器](figure/Figure_3.png)

### 数学模型解释

在数字信号处理中，二阶滤波器的差分方程可以表示为：

\[ y[n] = \frac{1}{a_0} \left( b_0 x[n] + b_1 x[n-1] + b_2 x[n-2] - a_1 y[n-1] - a_2 y[n-2] \right) \]

其中，\( x[n] \) 是输入信号，\( y[n] \) 是输出信号。

### 特点

- 二阶滤波器相比一阶滤波器具有更陡峭的频率响应，能够更精确地滤除不需要的频率成分。
- 它们的频率响应曲线在截止频率处变化更迅速。

### 优点

- 提供更好的选择性，能够更好地区分信号的频率成分。
- 在带通和带阻滤波器中，能够更有效地通过或阻止特定频带的信号。

### 缺点

- 设计和实现相对复杂，尤其是在需要特定频率响应特性的情况下。
- 数字实现时计算量较大。

### 适用场景

- 通信系统中的信号处理，如带通滤波器用于选取特定频段的信号。
- 音频处理，如均衡器中的各类滤波器。
- 图像处理中的边缘检测和增强。

## 3.FIP滤波

### 算法简介或算法定义

FIP（Fast Iterative Shrinkage-Thresholding Algorithm, 快速迭代收缩-阈值算法）滤波是一种用于信号处理和图像去噪的算法。它属于迭代收缩-阈值算法（Iterative Shrinkage-Thresholding Algorithms, ISTA）的范畴，被广泛应用于稀疏信号和图像复原领域。FIP滤波通过迭代的方式，利用收缩和阈值操作来逐步逼近最优解。通过加速收敛的技巧，如Nesterov加速梯度法，使得其比传统的ISTA算法更快。

### 算法的特点、优点、缺点以及适用场景

#### 特点

- **快速收敛**：通过引入加速技术，收敛速度比传统的ISTA更快。
- **稀疏性**：利用L1范数正则化促进稀疏解。
- **简单性**：算法实现相对简单，易于理解和实现。

#### 优点

- **快速**：收敛速度显著快于传统的ISTA。
- **有效**：在处理稀疏信号和图像去噪问题上表现良好。
- **灵活**：可以适用于各种稀疏信号复原问题。

#### 缺点

- **对参数敏感**：需要选择合适的参数，如步长和正则化参数。
- **可能陷入局部最优**：在某些情况下可能会陷入局部最优解。

#### 适用场景

- 图像去噪
- 稀疏信号恢复
- 压缩感知
- 机器学习中的特征选择

### 算法的原理和方法描述

FIP滤波的核心思想是通过迭代更新来逐步逼近问题的最优解。它的基本步骤包括梯度下降和收缩-阈值操作。

### 数学模型

假设我们要解决以下稀疏信号恢复问题：

\[ \min_x \left( \frac{1}{2} \| Ax - b \|_2^2 + \lambda \| x \|_1 \right) \]

其中，\( A \) 是一个矩阵，\( b \) 是观测向量，\( x \) 是待求解的稀疏向量，\( \lambda \) 是正则化参数。

### FIP的迭代步骤

1. **初始化**：设初始值 \( x^0 \)，步长 \( t_0 = 1 \) 和加速参数 \( y^1 = x^0 \)。
2. **迭代**：对 \( k = 1, 2, \ldots \)，执行以下步骤：
   - 计算梯度：\[ \nabla f(y^k) = A^T (A y^k - b) \]
   - 梯度下降步：\[ x^{k} = \text{Shrinkage}(y^k - \tau \nabla f(y^k), \lambda \tau) \]
   - 更新步长：\[ t_{k+1} = \frac{1 + \sqrt{1 + 4 t_k^2}}{2} \]
   - 更新加速参数：\[ y^{k+1} = x^k + \frac{t_k - 1}{t_{k+1}} (x^k - x^{k-1}) \]

其中，Shrinkage操作定义为：

\[ \text{Shrinkage}(x, \lambda) = \text{sign}(x) \max(|x| - \lambda, 0) \]

### 代码

[FIP滤波器](FIP_Filter.py)

### 输出结果

![FIP滤波器](figure/Figure_4.png)

### 时间复杂度

假设矩阵 \( A \) 的维度为 \( m \times n \)，FIP滤波的每次迭代主要涉及矩阵-向量乘法 \( A x \) 和 \( A^T x \)，其时间复杂度为 \( O(mn) \)。总的时间复杂度取决于迭代次数 \( k \)，一般情况下，FIP算法比ISTA需要更少的迭代次数。

### 总结

FIP滤波是一种高效的稀疏信号恢复算法，通过加速迭代技术，能够在较短时间内逼近最优解。它适用于各种稀疏信号和图像去噪问题，但需要对参数进行适当的选择和调整。

## 4.椭圆滤波

### 算法简介或算法定义

椭圆滤波器（Elliptic Filter），也称为Cauer滤波器，是一种具有极端陡峭滚降特性和可调波纹特性的滤波器。椭圆滤波器在通带和阻带中均具有等波纹特性，因其能够在指定频带内达到最陡峭的过渡而备受青睐。与巴特沃斯滤波器和切比雪夫滤波器相比，椭圆滤波器提供了最佳的频率选择性，但代价是通带和阻带中存在波纹。

### 算法的特点、优点、缺点以及适用场景

#### 特点

- **极端陡峭滚降**：在相同滤波器阶数下，椭圆滤波器提供最陡峭的频率过渡。
- **等波纹特性**：在通带和阻带中均具有等波纹特性。
- **参数化**：滤波器的设计参数（阶数、通带波纹、阻带波纹等）可以灵活调整。

#### 优点

- **高选择性**：能够在指定频率范围内实现高选择性，快速衰减。
- **灵活性**：可以通过调整参数满足不同应用需求。
- **高效**：在同样的阶数下，提供比其他类型滤波器更陡的滚降。

#### 缺点

- **波纹效应**：通带和阻带中存在波纹，可能影响某些应用场景的信号质量。
- **设计复杂**：参数选择和滤波器设计较为复杂，需要专业知识。

#### 适用场景

- **通信系统**：用于带通和带阻滤波，特别是需要高选择性的场合。
- **音频处理**：用于音频信号的噪声抑制和信号增强。
- **生物医学信号处理**：用于心电图等生物医学信号的滤波。

### 算法的原理和方法描述

椭圆滤波器通过优化通带和阻带的波纹特性，在给定阶数下实现最佳的频率选择性。其设计基于椭圆函数，因此得名椭圆滤波器。

### 数学模型

椭圆滤波器的传递函数可以表示为：

\[ H(s) = \frac{P(s)}{Q(s)} \]

其中，\( P(s) \) 和 \( Q(s) \) 分别是分子和分母多项式。这些多项式的系数是通过椭圆函数计算得到的，以满足特定的频率响应特性。

### 设计参数

- **阶数 (order)**：滤波器的阶数，决定了滤波器的复杂度和滚降特性。
- **通带波纹 (passband ripple, rp)**：通带内允许的最大波纹幅度。
- **阻带波纹 (stopband ripple, rs)**：阻带内允许的最大波纹幅度。
- **归一化截止频率 (normalized cutoff frequency, Wn)**：滤波器的截止频率，相对于奈奎斯特频率进行归一化。

### 代码

[椭圆滤波器](Elliptic_Filter.py)

### 输出结果

![椭圆滤波器](figure/Figure_5.png)

### 时间复杂度

椭圆滤波器的设计和实现涉及复杂的椭圆函数计算，其时间复杂度主要取决于滤波器的阶数和采样点数。通常情况下，椭圆滤波器设计和应用的时间复杂度可以接受，适用于实时信号处理。

### 总结

椭圆滤波器是一种高效且灵活的滤波器，在信号处理领域中广泛应用。其极端陡峭的滚降特性和可调波纹特性使其在需要高选择性和快速衰减的场合非常有用。然而，设计复杂性和通带、阻带中的波纹效应是其主要的缺点。合理选择设计参数可以最大化其优点，满足特定应用需求。

## 5.史密斯滤波器

### 算法简介或算法定义

史密斯滤波器（Smith Predictor）是一种用于控制系统中处理具有显著延迟的过程的控制算法。史密斯滤波器通过在控制回路中加入预测模型来补偿系统的延迟，从而提高系统的动态性能和稳定性。它最早由O.J.M. Smith在1957年提出，主要用于减少延迟对控制系统性能的影响。

### 算法的特点、优点、缺点以及适用场景

#### 特点

- **延迟补偿**：通过预测模型有效补偿系统中的延迟。
- **提高动态性能**：能够显著改善具有延迟的系统的动态响应。
- **模型依赖**：依赖于被控对象的精确模型。

#### 优点

- **改善稳定性**：通过补偿延迟，提高系统的稳定性。
- **提高响应速度**：能够在有延迟的情况下实现更快速的响应。
- **易于实现**：基于现有控制器易于添加预测补偿。

#### 缺点

- **模型准确性要求高**：需要精确的过程模型，否则可能导致补偿失效。
- **复杂性增加**：增加了系统设计和调试的复杂性。
- **鲁棒性有限**：对模型误差和系统变化的鲁棒性有限。

#### 适用场景

- **过程控制**：适用于具有显著延迟的工业过程控制，如化工、炼油等。
- **自动控制**：适用于自动控制系统中的延迟补偿，如温度控制、压力控制。
- **机器人控制**：适用于需要精确控制但存在信号传输延迟的机器人系统。

### 算法的原理和方法描述

史密斯滤波器的核心思想是在控制回路中加入一个预测模型，用于预测系统的未来输出，从而补偿延迟带来的影响。它的基本结构包括一个标准控制器、一个过程模型和一个预测模型。

### 数学模型

假设系统的传递函数为 \( G(s) \)，延迟为 \( e^{-Ls} \)，控制器的传递函数为 \( C(s) \)。史密斯滤波器的结构可以表示为：

\[ G_p(s) = \frac{G(s)}{1 + G(s)C(s)e^{-Ls}} \]

其中，\( G_p(s) \) 是预测模型的传递函数。

### 设计步骤

1. **确定被控对象模型**：获取被控对象的传递函数 \( G(s) \) 和延迟 \( L \)。
2. **设计标准控制器**：设计控制器 \( C(s) \)，假设系统没有延迟。
3. **构建预测模型**：基于对象模型 \( G(s) \) 和延迟 \( L \) 构建预测模型。
4. **闭环实现**：将预测模型加入到闭环控制系统中，实现延迟补偿。

### 代码

[史密斯滤波器](Smith_Filter.py)

### 输出结果

![史密斯滤波器](figure/Figure_6.png)

### 时间复杂度

史密斯滤波器的实现主要涉及传递函数的计算和控制器的设计，其时间复杂度主要取决于系统模型的复杂度和控制算法的复杂度。一般情况下，史密斯滤波器的计算开销是可以接受的，适用于实时控制系统。

### 总结

史密斯滤波器是一种用于补偿控制系统中显著延迟的有效方法。通过预测模型补偿延迟，提高系统的动态性能和稳定性。然而，其效果依赖于精确的过程模型，对模型误差和系统变化的鲁棒性有限。史密斯滤波器适用于各种具有显著延迟的过程控制和自动控制系统，是控制工程中常用的延迟补偿技术。

## 6.拉普拉斯滤波器

## 7.均值迁移滤波（Mean Shift Filter）

## 8.算术平均滤波法

## 9.IIR 数字滤波器

## 10.高斯滤波（Gaussian Filter）

## 11.中值滤波（Median Filter）

## 12.维纳滤波器

## 13.卡尔曼滤波
